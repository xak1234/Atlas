<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3I / ATLAS Brightness Tracker — Live</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial; }
    body {
      margin: 0;
      padding: 24px;
      background: #08101a;
      color: #e6eef8;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      position: relative;
    }
    #asteroidCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }
    .container {
      max-width: 900px;
      width: 100%;
      position: relative;
      z-index: 1;
    }
    .card {
      background: linear-gradient(180deg, rgba(15, 27, 42, 0.7), rgba(7, 16, 35, 0.7));
      border-radius: 12px;
      padding: 28px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 28px;
    }
    .header-left h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
    }
    .header-left .sub {
      color: #93aecd;
      font-size: 12px;
      margin-top: 4px;
    }
    .header-left .sub code {
      background: rgba(255, 255, 255, 0.05);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
    }
    .header-right {
      text-align: right;
    }
    .header-right > div {
      color: #93aecd;
      font-size: 12px;
      line-height: 1.6;
    }
    .status {
      color: #7ec8ff;
    }

    .content {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 24px;
    }

    .magnitude-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(126, 200, 255, 0.08);
      border-radius: 8px;
      border: 1px solid rgba(126, 200, 255, 0.15);
    }
    .big-mag {
      font-size: 64px;
      font-weight: 800;
      letter-spacing: -2px;
      line-height: 1;
      animation: pulseLuminosity 3s ease-in-out infinite;
    }
    @keyframes pulseLuminosity {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.7;
        transform: scale(1.05);
      }
    }
    .mag-source {
      font-size: 13px;
      color: #9fb3d2;
      margin-top: 8px;
      text-align: center;
    }
    .mag-status {
      font-size: 12px;
      font-weight: 600;
      margin-top: 6px;
      padding: 4px 10px;
      border-radius: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .mag-status.normal {
      background: rgba(126, 240, 163, 0.2);
      color: #7ef0a3;
    }
    .mag-status.abnormal {
      background: rgba(255, 155, 155, 0.2);
      color: #ff9b9b;
    }
    .mag-bar {
      width: 100%;
      height: 8px;
      background: #021827;
      border-radius: 999px;
      overflow: hidden;
      margin-top: 12px;
    }
    .mag-bar > i {
      display: block;
      height: 100%;
      width: 0%;
      transition: width 0.6s linear;
      background: linear-gradient(90deg, #ffd166, #ff6b6b);
    }
    .mag-scale {
      width: 100%;
      display: flex;
      justify-content: space-between;
      color: #9fb3d2;
      font-size: 11px;
      margin-top: 6px;
    }

    .distance-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: rgba(126, 200, 255, 0.08);
      border-radius: 8px;
      border: 1px solid rgba(126, 200, 255, 0.15);
      margin-top: 12px;
    }
    .distance-label {
      font-size: 11px;
      color: #9fb3d2;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .distance-value {
      font-size: 24px;
      font-weight: 700;
      color: #ffd166;
      margin-top: 4px;
    }
    .acceleration-status {
      font-size: 12px;
      font-weight: 600;
      color: #ff6b6b;
      margin-top: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      min-height: 16px;
    }

    .starmap-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    .contact-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(126, 200, 255, 0.08);
      border-radius: 8px;
      border: 1px solid rgba(126, 200, 255, 0.15);
    }
    .days-label {
      font-size: 11px;
      color: #9fb3d2;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }
    .days-to-contact {
      font-size: 32px;
      font-weight: 700;
      color: #7ef0a3;
      margin-bottom: 8px;
      text-align: center;
    }
    .contact-date {
      font-size: 14px;
      font-weight: 500;
      color: #9fb3d2;
      margin-bottom: 12px;
      text-align: center;
    }
    .contact-canvas-container {
      width: 100%;
      display: flex;
      justify-content: center;
      padding: 0;
    }
    .contact-canvas-container canvas {
      max-width: 100%;
      height: auto;
    }
    .observations {
      display: flex;
      flex-direction: column;
    }
    .observations h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
    }
    .observations .sub {
      color: #9fb3d2;
      font-size: 12px;
      margin-bottom: 12px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
    }
    th {
      font-weight: 600;
      color: #9fb3d2;
      background: rgba(255, 255, 255, 0.02);
    }
    .history-table {
      max-height: 320px;
      overflow-y: auto;
    }

    footer {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.04);
      font-size: 11px;
      color: #86a6c5;
    }
    footer code {
      background: rgba(255, 255, 255, 0.05);
      padding: 2px 6px;
      border-radius: 3px;
    }

    @media (max-width: 720px) {
      .content {
        grid-template-columns: 1fr;
      }
      body {
        padding: 16px;
      }
    }
  </style>
</head>
<body>
  <canvas id="asteroidCanvas"></canvas>
  <div class="container">
    <div class="card">
      <header>
        <div class="header-left">
          <h1>3I / ATLAS Unknown - Tracking — Live</h1>
          <div class="sub">Automated — data from <b>TheSkyLive</b> and <b>COBS</b>. Server: <code>https://atlas-c4gn.onrender.com</code></div>
        </div>
        <div class="header-right">
          <div id="lastUpdated">Last update: —</div>
          <div id="status" class="status">Status: connecting…</div>
        </div>
      </header>

      <div class="content">
        <div class="magnitude-card">
          <div class="big-mag" id="currentMag">—</div>
          <div class="mag-source" id="magSource">—</div>
          <div class="mag-status" id="magStatus">—</div>
          <div class="mag-bar">
            <i id="magBar" style="width: 0%"></i>
          </div>
          <div class="mag-scale">
            <div>Bright (0)</div>
            <div>Faint (18+)</div>
          </div>
          <div class="distance-card">
            <div class="distance-label">Distance to Earth</div>
            <div class="distance-value" id="distanceValue">—</div>
            <div class="distance-label" style="margin-top: 4px;">km</div>
            <div class="acceleration-status" id="accelerationStatus"></div>
          </div>
        </div>

      <div class="starmap-section">
        <div class="contact-section">
          <div class="days-label">Days to Contact</div>
          <div class="days-to-contact" id="daysToContact">—</div>
          <div class="contact-date" id="contactDate">—</div>
          <div class="contact-canvas-container">
            <canvas id="contactCanvas" width="220" height="100"></canvas>
          </div>
        </div>
        <div class="contact-section">
          <div class="days-label">Distance Tracking</div>
          <div class="contact-canvas-container">
            <canvas id="trackingCanvas" width="220" height="200"></canvas>
          </div>
        </div>
      </div>

        <div class="observations">
          <h3>Observations (latest first)</h3>
          <div class="sub">Auto-refresh: every 6 hours</div>
          <div class="history-table">
            <table id="historyTable">
              <thead>
                <tr>
                  <th>Time (UTC)</th>
                  <th>Source</th>
                  <th>Mag</th>
                  <th>Note</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>

      <footer>
        Franks-Apps.com Node server: <code>https://atlas-c4gn.onrender.com</code>. Contact for customizations.
      </footer>
    </div>
  </div>

<script>
// Live client for atlas-c4gn.onrender.com
const API_ROOT = 'https://atlas-c4gn.onrender.com';
const CLIENT_POLL_SECONDS = 21600; // 6 hours
const DISTANCE_POLL_SECONDS = 60; // Check real distance every 60 seconds
const DISTANCE_DISPLAY_INTERVAL = 1000; // Update display every 1 second (interpolated)
const MAX_HISTORY = 100;
let pollTimer = null;
let distanceTimer = null;
let distanceDisplayTimer = null;
let contactAnimationFrame = null;
let history = [];

// Distance tracking for smooth interpolation
let distanceState = {
  lastRealDistance: null,
  lastRealDistanceTime: null,
  currentDisplayDistance: null,
  velocityKmPerSecond: null, // Will be calculated from actual distance measurements
  trajectoryPoints: [], // Array of {time, distance} for graphing
  velocityHistory: [] // Array of {time, velocity} for acceleration detection
};

// Animation state for contact visualization dots
let contactAnimationState = {
  animationTime: 0 // Tracks animation progress (0 to 1, loops)
};

function formatUTC(d) {
  return new Date(d).toISOString().replace('T', ' ').replace('Z', ' UTC');
}

async function safeFetchJson(url) {
  try {
    const resp = await fetch(url, { cache: 'no-store' });
    const ct = resp.headers.get('content-type') || '';
    if (!resp.ok) {
      const text = await resp.text();
      return { ok: false, status: resp.status, text };
    }
    if (ct.includes('application/json') || ct.includes('text/json')) {
      try {
        const json = await resp.json();
        return { ok: true, json };
      } catch (e) {
        const text = await resp.text();
        return { ok: false, error: 'json', text };
      }
    }
    const text = await resp.text();
    return { ok: true, text };
  } catch (e) {
    return { ok: false, error: e.toString() };
  }
}

function updateUIFromEntry(entry) {
  const magEl = document.getElementById('currentMag');
  const srcEl = document.getElementById('magSource');
  const statusEl = document.getElementById('magStatus');
  const bar = document.getElementById('magBar');

  // Validate and sanitize inputs
  const mag = typeof entry.mag === 'number' && isFinite(entry.mag) ? entry.mag : 0;
  const src = String(entry.src || 'unknown');
  const note = entry.note ? String(entry.note) : '';
  
  magEl.textContent = mag.toFixed(2);
  srcEl.textContent = src + (note ? ' — ' + note : '');

  // Display magnitude status
  if (entry.magStatus) {
    statusEl.textContent = entry.magStatus.toUpperCase();
    statusEl.className = 'mag-status ' + entry.magStatus;
  } else {
    statusEl.textContent = '—';
    statusEl.className = 'mag-status';
  }

  const clamped = Math.max(0, Math.min(18, entry.mag));
  const pct = Math.round((18 - clamped) / 18 * 100);
  bar.style.width = pct + '%';
}

function drawContactVisualization(distanceKm) {
  const canvas = document.getElementById('contactCanvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Calculate days to contact based on ACTUAL velocity from distance tracking
  const SECONDS_PER_DAY = 86400;
  // Only calculate if we have a valid velocity (calculated from actual measurements)
  // Use Math.abs to ensure positive velocity (approaching Earth)
  const actualVelocity = distanceState.velocityKmPerSecond !== null && distanceState.velocityKmPerSecond > 0 
    ? Math.abs(distanceState.velocityKmPerSecond) 
    : null;
  
  // Update the days display and contact date
  const daysEl = document.getElementById('daysToContact');
  const dateEl = document.getElementById('contactDate');
  if (actualVelocity && distanceKm && distanceKm > 0) {
    const totalSeconds = distanceKm / actualVelocity;
    const daysToContact = totalSeconds / SECONDS_PER_DAY;
    
    // Debug logging
    console.log(`Days calculation: distance=${distanceKm.toLocaleString()} km, velocity=${actualVelocity.toFixed(2)} km/s, days=${daysToContact.toFixed(1)}`);
    
    if (daysToContact > 0 && isFinite(daysToContact)) {
      // Calculate the contact date
      const now = new Date();
      const contactDate = new Date(now.getTime() + daysToContact * SECONDS_PER_DAY * 1000);
      const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                         'July', 'August', 'September', 'October', 'November', 'December'];
      const month = monthNames[contactDate.getMonth()];
      const day = contactDate.getDate();
      const year = contactDate.getFullYear();
      
      // Calculate days between today and contact date
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const contact = new Date(contactDate);
      contact.setHours(0, 0, 0, 0);
      const daysDifference = Math.round((contact - today) / (1000 * 60 * 60 * 24));
      
      daysEl.textContent = daysDifference.toLocaleString();
      dateEl.textContent = `${month} ${day}, ${year}`;
    } else {
      daysEl.textContent = '—';
      dateEl.textContent = '—';
    }
  } else {
    daysEl.textContent = '—';
    dateEl.textContent = '—';
    if (!actualVelocity) {
      console.log('Days calculation: No valid velocity available');
    }
  }
  
  // Draw visualization
  const centerY = canvas.height / 2;
  
  // Draw Earth (green circle on the right)
  ctx.fillStyle = '#7ef0a3';
  ctx.beginPath();
  ctx.arc(180, centerY, 18, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw Earth outline
  ctx.strokeStyle = '#7ef0a3';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Draw simple Earth details (continents)
  ctx.fillStyle = '#05a84a';
  ctx.beginPath();
  ctx.arc(185, centerY - 5, 4, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(175, centerY + 6, 3, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw spaceship (red triangle pointing right toward Earth)
  const shipX = 30;
  ctx.fillStyle = '#ff6b6b';
  ctx.beginPath();
  ctx.moveTo(shipX + 12, centerY); // point facing right
  ctx.lineTo(shipX - 8, centerY - 8);
  ctx.lineTo(shipX - 8, centerY + 8);
  ctx.closePath();
  ctx.fill();
  
  // Draw line from ship to Earth
  ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(shipX + 12, centerY);
  ctx.lineTo(180 - 18, centerY);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Draw animated dots moving from ship to Earth
  const earthX = 180 - 18;
  const shipEndX = shipX + 12;
  const pathLength = earthX - shipEndX;
  
  // Draw multiple dots at different positions along the path
  const numDots = 3;
  const dotSpacing = 0.25; // Spacing between dots (as fraction of path)
  
  ctx.fillStyle = '#ff6b6b';
  for (let i = 0; i < numDots; i++) {
    // Calculate dot position with animation offset
    const baseProgress = (contactAnimationState.animationTime + i * dotSpacing) % 1;
    const dotX = shipEndX + baseProgress * pathLength;
    const dotY = centerY;
    
    // Only draw if dot is between ship and Earth
    if (dotX >= shipEndX && dotX <= earthX) {
      ctx.beginPath();
      ctx.arc(dotX, dotY, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // Start animation loop if not already running
  startContactAnimation();
}

// Animation function for contact visualization dots
function animateContact() {
  contactAnimationState.animationTime += 0.015; // Adjust speed (0.01 = slower, 0.05 = faster)
  if (contactAnimationState.animationTime >= 1) {
    contactAnimationState.animationTime = 0; // Loop back
  }
  
  // Redraw the visualization
  if (distanceState.currentDisplayDistance !== null) {
    drawContactVisualization(distanceState.currentDisplayDistance);
  }
  
  contactAnimationFrame = requestAnimationFrame(animateContact);
}

function startContactAnimation() {
  if (contactAnimationFrame === null) {
    contactAnimationFrame = requestAnimationFrame(animateContact);
  }
}

function drawTrackingVisualization(distanceKm) {
  const canvas = document.getElementById('trackingCanvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  
  // Background
  ctx.fillStyle = '#08101a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw orbital path (arc from comet to Earth)
  ctx.strokeStyle = 'rgba(126, 200, 255, 0.2)';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.arc(centerX, centerY, 100, -Math.PI * 0.3, Math.PI * 0.3, false);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Calculate progress toward Earth (0 = start at 310M km, 1 = Earth at 0 km)
  const startDistance = 310000000; // ~310M km
  const endDistance = 269000000;   // ~269M km (closest approach)
  const progress = (startDistance - distanceKm) / (startDistance - endDistance);
  const clampedProgress = Math.max(0, Math.min(1, progress));
  
  // Calculate comet position on the arc
  const angle = -Math.PI * 0.3 + (Math.PI * 0.6) * clampedProgress;
  const cometRadius = 100 - clampedProgress * 70; // Moves closer to Earth
  const cometX = centerX + Math.cos(angle) * cometRadius;
  const cometY = centerY + Math.sin(angle) * cometRadius;
  
  // Draw Sun (yellow circle in upper left)
  ctx.fillStyle = '#FFB81C';
  ctx.shadowColor = 'rgba(255, 184, 28, 0.5)';
  ctx.shadowBlur = 20;
  ctx.beginPath();
  ctx.arc(centerX - 120, centerY - 80, 15, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowColor = 'transparent';
  ctx.fillStyle = '#9fb3d2';
  ctx.font = '11px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('Sun', centerX - 120, centerY - 60);
  
  // Draw Earth (blue circle on the right)
  ctx.fillStyle = '#4A9EE8';
  ctx.shadowColor = 'rgba(74, 158, 232, 0.5)';
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.arc(centerX + 100, centerY, 12, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw Earth details (continents)
  ctx.fillStyle = '#2E7D3F';
  ctx.beginPath();
  ctx.arc(centerX + 102, centerY - 4, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(centerX + 96, centerY + 3, 2.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowColor = 'transparent';
  
  ctx.fillStyle = '#9fb3d2';
  ctx.textAlign = 'center';
  ctx.fillText('Earth', centerX + 100, centerY + 28);
  
  // Draw comet (white/cyan glowing sphere with tail)
  ctx.fillStyle = '#7ef0a3';
  ctx.shadowColor = 'rgba(126, 240, 163, 0.6)';
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.arc(cometX, cometY, 8, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw comet tail (pointing away from sun)
  const tailAngle = Math.atan2(cometY - (centerY - 80), cometX - (centerX - 120));
  const tailStartX = cometX + Math.cos(tailAngle) * 8;
  const tailStartY = cometY + Math.sin(tailAngle) * 8;
  const tailEndX = cometX + Math.cos(tailAngle) * 35;
  const tailEndY = cometY + Math.sin(tailAngle) * 35;
  
  ctx.strokeStyle = 'rgba(126, 240, 163, 0.4)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(tailStartX, tailStartY);
  ctx.lineTo(tailEndX, tailEndY);
  ctx.stroke();
  ctx.shadowColor = 'transparent';
  
  // Draw dashed line from comet to Earth
  ctx.strokeStyle = 'rgba(255, 107, 107, 0.4)';
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  ctx.moveTo(cometX, cometY);
  ctx.lineTo(centerX + 100, centerY);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Draw distance label
  ctx.fillStyle = '#ffd166';
  ctx.font = 'bold 12px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText(distanceKm.toLocaleString('en-US', { maximumFractionDigits: 0 }) + ' km', centerX, 30);
  
  // Draw "sky movement" label
  ctx.fillStyle = '#9fb3d2';
  ctx.font = '10px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('orbital trajectory', centerX, canvas.height - 15);
}

function renderHistoryTable() {
  const tbody = document.querySelector('#historyTable tbody');
  tbody.innerHTML = '';
  for (let row of history.slice(0, MAX_HISTORY)) {
    const tr = document.createElement('tr');
    
    // Time cell
    const tdTime = document.createElement('td');
    tdTime.textContent = formatUTC(row.time);
    tr.appendChild(tdTime);
    
    // Source cell
    const tdSrc = document.createElement('td');
    tdSrc.textContent = String(row.src || '');
    tr.appendChild(tdSrc);
    
    // Magnitude cell
    const tdMag = document.createElement('td');
    tdMag.textContent = row.mag.toFixed(2);
    tr.appendChild(tdMag);
    
    // Note cell
    const tdNote = document.createElement('td');
    tdNote.textContent = String(row.note || '');
    tr.appendChild(tdNote);
    
    tbody.appendChild(tr);
  }
}

async function fetchDistance() {
  try {
    const res = await safeFetchJson(API_ROOT + '/api/distance');
    if (res.ok && res.json && res.json.distanceKm !== null) {
      const newDistance = res.json.distanceKm;
      const now = Date.now();
      
      // Add to trajectory points for graphing
      distanceState.trajectoryPoints.push({ time: now, distance: newDistance });
      
      // Keep only last 2 hours of data (120 minutes)
      const twoHoursMs = 2 * 60 * 60 * 1000;
      distanceState.trajectoryPoints = distanceState.trajectoryPoints.filter(
        point => now - point.time < twoHoursMs
      );
      
      // Calculate velocity using trajectory points for better accuracy
      // Prefer using points with at least 5 minutes of time difference for stability
      const MIN_TIME_FOR_VELOCITY_SECONDS = 300; // 5 minutes minimum
      
      if (distanceState.trajectoryPoints.length >= 2) {
        const points = distanceState.trajectoryPoints;
        const newestPoint = points[points.length - 1];
        
        // Find the oldest point that's at least MIN_TIME_FOR_VELOCITY_SECONDS ago
        let bestOldPoint = null;
        let bestTimeDiff = 0;
        
        for (let i = points.length - 2; i >= 0; i--) {
          const timeDiffSeconds = (newestPoint.time - points[i].time) / 1000;
          if (timeDiffSeconds >= MIN_TIME_FOR_VELOCITY_SECONDS) {
            bestOldPoint = points[i];
            bestTimeDiff = timeDiffSeconds;
            break;
          }
        }
        
        // If we have a good point pair, calculate velocity
        if (bestOldPoint) {
          const distanceDiffKm = bestOldPoint.distance - newestPoint.distance; // Positive if approaching
          
          if (bestTimeDiff > 0 && Math.abs(distanceDiffKm) > 0) {
            // Calculate velocity (km/s) - use absolute value to ensure positive
            const calculatedVelocity = Math.abs(distanceDiffKm) / bestTimeDiff;
            
            // Only update if we have a reasonable velocity (between 1 and 200 km/s for comets)
            // This filters out noise from small measurement errors
            if (calculatedVelocity >= 1 && calculatedVelocity <= 200) {
              // Track velocity history for acceleration detection
              distanceState.velocityHistory.push({ time: now, velocity: calculatedVelocity });
              
              // Keep only last 10 minutes of velocity history
              const tenMinutesMs = 10 * 60 * 1000;
              distanceState.velocityHistory = distanceState.velocityHistory.filter(
                entry => now - entry.time < tenMinutesMs
              );
              
              distanceState.velocityKmPerSecond = calculatedVelocity;
              console.log(`Distance updated: ${newDistance.toLocaleString()} km | Velocity: ${distanceState.velocityKmPerSecond.toFixed(2)} km/s | Time window: ${(bestTimeDiff / 60).toFixed(1)} min`);
              
              // Update acceleration status
              updateAccelerationStatus();
            } else {
              console.log(`Velocity calculation out of range: ${calculatedVelocity.toFixed(2)} km/s (filtered)`);
            }
          }
        } else if (distanceState.lastRealDistance !== null && distanceState.lastRealDistanceTime !== null) {
          // Fallback: use last two readings if we don't have enough history yet
          const timeDiffSeconds = (now - distanceState.lastRealDistanceTime) / 1000;
          const distanceDiffKm = distanceState.lastRealDistance - newDistance;
          
          if (timeDiffSeconds >= 60 && Math.abs(distanceDiffKm) > 0) { // At least 1 minute
            const calculatedVelocity = Math.abs(distanceDiffKm) / timeDiffSeconds;
            if (calculatedVelocity >= 1 && calculatedVelocity <= 200) {
              // Track velocity history for acceleration detection
              distanceState.velocityHistory.push({ time: now, velocity: calculatedVelocity });
              
              // Keep only last 10 minutes of velocity history
              const tenMinutesMs = 10 * 60 * 1000;
              distanceState.velocityHistory = distanceState.velocityHistory.filter(
                entry => now - entry.time < tenMinutesMs
              );
              
              distanceState.velocityKmPerSecond = calculatedVelocity;
              console.log(`Distance updated: ${newDistance.toLocaleString()} km | Velocity: ${distanceState.velocityKmPerSecond.toFixed(2)} km/s | Time window: ${(timeDiffSeconds / 60).toFixed(1)} min (fallback)`);
              
              // Update acceleration status
              updateAccelerationStatus();
            }
          }
        }
      } else {
        console.log(`Initial distance: ${newDistance.toLocaleString()} km (need more points for velocity)`);
      }
      
      // Update the state with new real distance
      distanceState.lastRealDistance = newDistance;
      distanceState.lastRealDistanceTime = now;
      distanceState.currentDisplayDistance = newDistance;
      
      // Update display immediately with the new real distance
      updateDistanceDisplay(newDistance);
    }
  } catch (e) {
    console.error('Distance fetch failed:', e);
  }
}

function updateAccelerationStatus() {
  const statusEl = document.getElementById('accelerationStatus');
  if (!statusEl) return;
  
  // Need at least 2 velocity measurements to detect acceleration/deceleration
  if (distanceState.velocityHistory.length < 2) {
    statusEl.textContent = '';
    return;
  }
  
  const history = distanceState.velocityHistory;
  const recentCount = Math.min(5, history.length); // Use last 5 measurements
  const recentVelocities = history.slice(-recentCount);
  
  // Calculate average velocity for older half vs newer half
  const midPoint = Math.floor(recentVelocities.length / 2);
  const olderVelocities = recentVelocities.slice(0, midPoint);
  const newerVelocities = recentVelocities.slice(midPoint);
  
  if (olderVelocities.length === 0 || newerVelocities.length === 0) {
    statusEl.textContent = '';
    return;
  }
  
  const avgOlder = olderVelocities.reduce((sum, v) => sum + v.velocity, 0) / olderVelocities.length;
  const avgNewer = newerVelocities.reduce((sum, v) => sum + v.velocity, 0) / newerVelocities.length;
  
  // Threshold: velocity change must be at least 0.5 km/s to be significant
  const velocityDiff = avgNewer - avgOlder;
  const threshold = 0.5;
  
  if (velocityDiff > threshold) {
    statusEl.textContent = 'Accelerating';
  } else if (velocityDiff < -threshold) {
    statusEl.textContent = 'Decelerating';
  } else {
    statusEl.textContent = '';
  }
}

function updateDistanceDisplay(distanceKm) {
  const distEl = document.getElementById('distanceValue');
  distEl.textContent = distanceKm.toLocaleString('en-US', { maximumFractionDigits: 0 });
  // Update the visualizations with the new distance
  drawContactVisualization(distanceKm);
  drawTrackingVisualization(distanceKm);
}

function interpolateDistance() {
  if (distanceState.lastRealDistanceTime === null || distanceState.velocityKmPerSecond === null) {
    return;
  }
  
  const now = Date.now();
  const timeSinceLastFetchSeconds = (now - distanceState.lastRealDistanceTime) / 1000;
  
  // Calculate interpolated distance based on velocity
  // Velocity is positive (approaching), so distance decreases
  const distanceChange = distanceState.velocityKmPerSecond * timeSinceLastFetchSeconds;
  const interpolatedDistance = distanceState.lastRealDistance - distanceChange;
  
  // Update display with interpolated value
  distanceState.currentDisplayDistance = interpolatedDistance;
  updateDistanceDisplay(interpolatedDistance);
}

async function fetchLatest() {
  document.getElementById('status').textContent = 'Status: fetching…';
  try {
    const res = await safeFetchJson(API_ROOT + '/api/latest');
    if (!res.ok) {
      document.getElementById('status').textContent = 'Status: fetch failed';
      return;
    }
    const cache = res.json.cache || res.json;
    let mag = cache.latestMag ?? cache.observedMag ?? cache.predictedMag ?? null;
    let src = cache.source ?? 'unknown';
    let magStatus = cache.magStatus ?? 'normal';

    if (mag === null) {
      document.getElementById('status').textContent = 'Status: no data';
      return;
    }

    // Validate and sanitize data
    const parsedMag = Number(mag);
    if (!isFinite(parsedMag) || parsedMag < 0 || parsedMag > 30) {
      console.error('Invalid magnitude value:', mag);
      document.getElementById('status').textContent = 'Status: invalid data';
      return;
    }

    const entry = {
      time: new Date(),
      src: String(src).slice(0, 100), // Limit length
      mag: parsedMag,
      magStatus: ['normal', 'abnormal'].includes(magStatus) ? magStatus : 'normal',
      note: ''
    };

    // add to history if new
    if (!history.length || history[0].mag !== entry.mag) {
      history.unshift(entry);
      if (history.length > MAX_HISTORY) history.pop();
    }

    renderHistoryTable();
    updateUIFromEntry(entry);

    renderHistoryTable();
    updateUIFromEntry(entry);

    document.getElementById('lastUpdated').textContent = 'Last update: ' + formatUTC(new Date(cache.updated || Date.now()));
    document.getElementById('status').textContent = 'Status: OK';
  } catch (e) {
    document.getElementById('status').textContent = 'Status: error';
    console.error(e);
  }
}

// start automatic polling
(async function() {
  // immediate fetch on page load
  await fetchLatest();
  await fetchDistance();
  // then schedule for magnitude (every 6 hours) and distance (every 60 seconds for real data)
  pollTimer = setInterval(fetchLatest, CLIENT_POLL_SECONDS * 1000);
  distanceTimer = setInterval(fetchDistance, DISTANCE_POLL_SECONDS * 1000);
  // Interpolate distance display every second
  distanceDisplayTimer = setInterval(interpolateDistance, DISTANCE_DISPLAY_INTERVAL);
})();

// ===== ASTEROID GAME BACKGROUND ANIMATION =====
(function() {
  const canvas = document.getElementById('asteroidCanvas');
  const ctx = canvas.getContext('2d');
  
  // Set canvas size to match window
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  
  // Game state
  const ship = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    angle: 0,
    velocity: { x: 0, y: 0 },
    size: 15,
    thrust: false,
    rotation: 0,
    exploded: false,
    respawnTime: 0
  };
  
  const asteroids = [];
  const bullets = [];
  const particles = [];
  const stars = [];
  const ufos = [];
  const ufoBullets = [];
  let lastHugeAsteroidTime = Date.now();
  const HUGE_ASTEROID_INTERVAL = 13800; // ~14 seconds (15% less frequent)
  let lastUfoTime = Date.now();
  let nextUfoInterval = 20000 + Math.random() * 15000; // 20-35 seconds
  let lastHyperspaceTime = 0;
  const HYPERSPACE_COOLDOWN = 8000; // 8 seconds
  
  // Create background stars
  for (let i = 0; i < 150; i++) {
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: Math.random() * 1.5 + 0.5,
      opacity: Math.random() * 0.5 + 0.3
    });
  }
  
  // Create initial asteroids
  function createAsteroid(x, y, size, velocity) {
    return {
      x: x || Math.random() * canvas.width,
      y: y || Math.random() * canvas.height,
      velocity: velocity || {
        x: (Math.random() - 0.5) * 2,
        y: (Math.random() - 0.5) * 2
      },
      size: size || Math.random() * 30 + 20,
      angle: Math.random() * Math.PI * 2,
      rotation: (Math.random() - 0.5) * 0.05,
      points: generateAsteroidShape()
    };
  }
  
  // Create huge asteroid entering from edge
  function spawnHugeAsteroid() {
    const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
    let x, y, velocity;
    const speed = 3 + Math.random() * 2; // Faster than normal
    const size = 80 + Math.random() * 40; // Much larger (80-120)
    
    if (edge === 0) { // top
      x = Math.random() * canvas.width;
      y = -size;
      velocity = { x: (Math.random() - 0.5) * 2, y: speed };
    } else if (edge === 1) { // right
      x = canvas.width + size;
      y = Math.random() * canvas.height;
      velocity = { x: -speed, y: (Math.random() - 0.5) * 2 };
    } else if (edge === 2) { // bottom
      x = Math.random() * canvas.width;
      y = canvas.height + size;
      velocity = { x: (Math.random() - 0.5) * 2, y: -speed };
    } else { // left
      x = -size;
      y = Math.random() * canvas.height;
      velocity = { x: speed, y: (Math.random() - 0.5) * 2 };
    }
    
    asteroids.push(createAsteroid(x, y, size, velocity));
    console.log(`Huge asteroid spawned! Size: ${size.toFixed(0)}`);
  }
  
  // Spawn UFO
  function spawnUfo() {
    const edge = Math.floor(Math.random() * 2); // 0=left, 1=right
    const y = Math.random() * (canvas.height * 0.8) + canvas.height * 0.1; // Middle 80% of screen
    let x, velocityX;
    
    if (edge === 0) { // left side, moving right
      x = -60;
      velocityX = 4 + Math.random() * 2;
    } else { // right side, moving left
      x = canvas.width + 60;
      velocityX = -(4 + Math.random() * 2);
    }
    
    ufos.push({
      x,
      y,
      velocityX,
      size: 30,
      bobOffset: Math.random() * Math.PI * 2,
      glowPhase: 0,
      lastShotTime: Date.now()
    });
    console.log('UFO spawned!');
  }
  
  // Update UFOs
  function updateUfos() {
    ufos.forEach((ufo, index) => {
      ufo.x += ufo.velocityX;
      ufo.bobOffset += 0.05;
      ufo.glowPhase += 0.1;
      
      // Shoot at ship if not exploded and on screen
      if (!ship.exploded && ufo.x > 0 && ufo.x < canvas.width) {
        const now = Date.now();
        if (now - ufo.lastShotTime > 1500) { // Shoot every 1.5 seconds
          const bobY = ufo.y + Math.sin(ufo.bobOffset) * 5;
          const dx = ship.x - ufo.x;
          const dy = ship.y - bobY;
          const angle = Math.atan2(dy, dx);
          
          ufoBullets.push({
            x: ufo.x,
            y: bobY,
            velocity: {
              x: Math.cos(angle) * 4,
              y: Math.sin(angle) * 4
            },
            life: 120
          });
          ufo.lastShotTime = now;
        }
      }
      
      // Remove if off screen
      if (ufo.x < -100 || ufo.x > canvas.width + 100) {
        ufos.splice(index, 1);
      }
    });
  }
  
  // Update UFO bullets
  function updateUfoBullets() {
    ufoBullets.forEach((bullet, index) => {
      bullet.x += bullet.velocity.x;
      bullet.y += bullet.velocity.y;
      bullet.life--;
      
      // Check collision with ship
      if (!ship.exploded) {
        const dx = bullet.x - ship.x;
        const dy = bullet.y - ship.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < ship.size) {
          // Ship hit by UFO bullet!
          ship.exploded = true;
          ship.respawnTime = Date.now() + 3000;
          createParticles(ship.x, ship.y, 30);
          ufoBullets.splice(index, 1);
          console.log('Ship destroyed by UFO!');
          return;
        }
      }
      
      if (bullet.life <= 0 || bullet.x < 0 || bullet.x > canvas.width || 
          bullet.y < 0 || bullet.y > canvas.height) {
        ufoBullets.splice(index, 1);
      }
    });
  }
  
  // Draw UFOs
  function drawUfos() {
    ufos.forEach(ufo => {
      const bobY = ufo.y + Math.sin(ufo.bobOffset) * 5;
      
      ctx.save();
      ctx.translate(ufo.x, bobY);
      
      // Glow effect
      const glowIntensity = 0.3 + Math.sin(ufo.glowPhase) * 0.2;
      ctx.shadowColor = `rgba(126, 240, 163, ${glowIntensity})`;
      ctx.shadowBlur = 20;
      
      // UFO dome (top)
      ctx.fillStyle = 'rgba(126, 240, 163, 0.7)';
      ctx.beginPath();
      ctx.ellipse(0, -5, ufo.size * 0.4, ufo.size * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // UFO body (disc)
      ctx.fillStyle = 'rgba(126, 200, 255, 0.6)';
      ctx.strokeStyle = 'rgba(126, 240, 163, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, ufo.size, ufo.size * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Windows
      ctx.fillStyle = 'rgba(255, 255, 100, 0.9)';
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const wx = Math.cos(angle) * ufo.size * 0.5;
        const wy = Math.sin(angle) * ufo.size * 0.15;
        ctx.beginPath();
        ctx.arc(wx, wy, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Light beam (occasionally)
      if (Math.sin(ufo.glowPhase) > 0.5) {
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(126, 240, 163, 0.15)';
        ctx.beginPath();
        ctx.moveTo(-10, ufo.size * 0.3);
        ctx.lineTo(-15, 80);
        ctx.lineTo(15, 80);
        ctx.lineTo(10, ufo.size * 0.3);
        ctx.closePath();
        ctx.fill();
      }
      
      ctx.restore();
    });
  }
  
  function generateAsteroidShape() {
    const points = [];
    const numPoints = Math.floor(Math.random() * 4) + 6;
    for (let i = 0; i < numPoints; i++) {
      const angle = (i / numPoints) * Math.PI * 2;
      const radius = 0.7 + Math.random() * 0.3;
      points.push({ angle, radius });
    }
    return points;
  }
  
  // Initialize asteroids
  for (let i = 0; i < 8; i++) {
    asteroids.push(createAsteroid());
  }
  
  // Create particle effect
  function createParticles(x, y, count) {
    for (let i = 0; i < count; i++) {
      particles.push({
        x,
        y,
        velocity: {
          x: (Math.random() - 0.5) * 4,
          y: (Math.random() - 0.5) * 4
        },
        life: 1,
        size: Math.random() * 2 + 1
      });
    }
  }
  
  // Autonomous ship AI
  function updateShipAI() {
    // Check if ship should respawn
    if (ship.exploded) {
      if (Date.now() >= ship.respawnTime) {
        ship.exploded = false;
        ship.x = canvas.width / 2;
        ship.y = canvas.height / 2;
        ship.velocity = { x: 0, y: 0 };
        ship.angle = 0;
        console.log('Ship respawned!');
      }
      return; // Don't update AI while exploded
    }
    
    // Find nearest asteroid
    let nearest = null;
    let nearestDist = Infinity;
    
    asteroids.forEach(asteroid => {
      const dx = asteroid.x - ship.x;
      const dy = asteroid.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < nearestDist) {
        nearestDist = dist;
        nearest = asteroid;
      }
    });
    
    if (nearest) {
      // Aim at nearest asteroid
      const dx = nearest.x - ship.x;
      const dy = nearest.y - ship.y;
      const targetAngle = Math.atan2(dy, dx);
      
      // Smooth rotation toward target
      let angleDiff = targetAngle - ship.angle;
      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
      
      ship.angle += angleDiff * 0.05;
      
      // Shoot periodically
      if (Math.random() < 0.02 && Math.abs(angleDiff) < 0.3) {
        bullets.push({
          x: ship.x + Math.cos(ship.angle) * ship.size,
          y: ship.y + Math.sin(ship.angle) * ship.size,
          velocity: {
            x: Math.cos(ship.angle) * 6,
            y: Math.sin(ship.angle) * 6
          },
          life: 60
        });
      }
      
      // Thrust occasionally
      ship.thrust = Math.random() < 0.3;
      if (ship.thrust) {
        ship.velocity.x += Math.cos(ship.angle) * 0.1;
        ship.velocity.y += Math.sin(ship.angle) * 0.1;
      }
      
      // Use hyperspace in dangerous situations
      const now = Date.now();
      if (now - lastHyperspaceTime > HYPERSPACE_COOLDOWN) {
        // Check if in danger (nearby large asteroid or UFO bullets)
        let inDanger = false;
        
        asteroids.forEach(asteroid => {
          if (asteroid.size > 50) {
            const dx = asteroid.x - ship.x;
            const dy = asteroid.y - ship.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 100) inDanger = true;
          }
        });
        
        ufoBullets.forEach(bullet => {
          const dx = bullet.x - ship.x;
          const dy = bullet.y - ship.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 80) inDanger = true;
        });
        
        if (inDanger && Math.random() < 0.1) {
          // Activate hyperspace!
          createParticles(ship.x, ship.y, 15);
          ship.x = Math.random() * canvas.width;
          ship.y = Math.random() * canvas.height;
          ship.velocity.x = 0;
          ship.velocity.y = 0;
          createParticles(ship.x, ship.y, 15);
          lastHyperspaceTime = now;
          console.log('Hyperspace jump!');
        }
      }
    }
    
    // Apply velocity and friction
    ship.velocity.x *= 0.99;
    ship.velocity.y *= 0.99;
    ship.x += ship.velocity.x;
    ship.y += ship.velocity.y;
    
    // Wrap around screen
    if (ship.x < 0) ship.x = canvas.width;
    if (ship.x > canvas.width) ship.x = 0;
    if (ship.y < 0) ship.y = canvas.height;
    if (ship.y > canvas.height) ship.y = 0;
  }
  
  // Update asteroids
  function updateAsteroids() {
    asteroids.forEach((asteroid, index) => {
      asteroid.x += asteroid.velocity.x;
      asteroid.y += asteroid.velocity.y;
      asteroid.angle += asteroid.rotation;
      
      // Wrap around screen
      if (asteroid.x < -50) asteroid.x = canvas.width + 50;
      if (asteroid.x > canvas.width + 50) asteroid.x = -50;
      if (asteroid.y < -50) asteroid.y = canvas.height + 50;
      if (asteroid.y > canvas.height + 50) asteroid.y = -50;
      
      // Check collision with ship (only large asteroids)
      if (!ship.exploded && asteroid.size > 50) {
        const dx = ship.x - asteroid.x;
        const dy = ship.y - asteroid.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < asteroid.size + ship.size) {
          // Ship explodes!
          ship.exploded = true;
          ship.respawnTime = Date.now() + 3000; // Respawn after 3 seconds
          createParticles(ship.x, ship.y, 30);
          console.log('Ship destroyed by large asteroid!');
        }
      }
      
      // Check collision with bullets
      bullets.forEach((bullet, bIndex) => {
        const dx = bullet.x - asteroid.x;
        const dy = bullet.y - asteroid.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < asteroid.size) {
          // Hit!
          createParticles(asteroid.x, asteroid.y, 10);
          bullets.splice(bIndex, 1);
          
          // Split asteroid if large enough
          if (asteroid.size > 15) {
            asteroids.push(createAsteroid(asteroid.x, asteroid.y, asteroid.size / 2));
            asteroids.push(createAsteroid(asteroid.x, asteroid.y, asteroid.size / 2));
          }
          asteroids.splice(index, 1);
        }
      });
    });
    
    // Maintain minimum asteroid count
    while (asteroids.length < 6) {
      const edge = Math.floor(Math.random() * 4);
      let x, y;
      if (edge === 0) { x = Math.random() * canvas.width; y = -50; }
      else if (edge === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; }
      else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 50; }
      else { x = -50; y = Math.random() * canvas.height; }
      asteroids.push(createAsteroid(x, y));
    }
  }
  
  // Update bullets
  function updateBullets() {
    bullets.forEach((bullet, index) => {
      bullet.x += bullet.velocity.x;
      bullet.y += bullet.velocity.y;
      bullet.life--;
      
      if (bullet.life <= 0 || bullet.x < 0 || bullet.x > canvas.width || 
          bullet.y < 0 || bullet.y > canvas.height) {
        bullets.splice(index, 1);
      }
    });
  }
  
  // Update particles
  function updateParticles() {
    particles.forEach((particle, index) => {
      particle.x += particle.velocity.x;
      particle.y += particle.velocity.y;
      particle.life -= 0.02;
      
      if (particle.life <= 0) {
        particles.splice(index, 1);
      }
    });
  }
  
  // Draw functions
  function drawStars() {
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    stars.forEach(star => {
      ctx.globalAlpha = star.opacity;
      ctx.fillRect(star.x, star.y, star.size, star.size);
    });
    ctx.globalAlpha = 1;
  }
  
  function drawShip() {
    if (ship.exploded) return; // Don't draw if exploded
    
    ctx.save();
    ctx.translate(ship.x, ship.y);
    ctx.rotate(ship.angle);
    
    // Ship body (triangle)
    ctx.strokeStyle = 'rgba(126, 240, 163, 0.6)';
    ctx.fillStyle = 'rgba(126, 240, 163, 0.1)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ship.size, 0);
    ctx.lineTo(-ship.size, -ship.size / 2);
    ctx.lineTo(-ship.size, ship.size / 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Thrust flame
    if (ship.thrust) {
      ctx.fillStyle = 'rgba(255, 107, 107, 0.6)';
      ctx.beginPath();
      ctx.moveTo(-ship.size, -ship.size / 3);
      ctx.lineTo(-ship.size - 10, 0);
      ctx.lineTo(-ship.size, ship.size / 3);
      ctx.closePath();
      ctx.fill();
    }
    
    ctx.restore();
  }
  
  function drawAsteroids() {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.lineWidth = 2;
    
    asteroids.forEach(asteroid => {
      ctx.save();
      ctx.translate(asteroid.x, asteroid.y);
      ctx.rotate(asteroid.angle);
      
      ctx.beginPath();
      asteroid.points.forEach((point, i) => {
        const x = Math.cos(point.angle) * asteroid.size * point.radius;
        const y = Math.sin(point.angle) * asteroid.size * point.radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      ctx.restore();
    });
  }
  
  function drawBullets() {
    ctx.fillStyle = 'rgba(126, 200, 255, 0.8)';
    bullets.forEach(bullet => {
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
      ctx.fill();
    });
  }
  
  function drawUfoBullets() {
    ctx.fillStyle = 'rgba(255, 107, 107, 0.8)';
    ctx.shadowColor = 'rgba(255, 107, 107, 0.5)';
    ctx.shadowBlur = 10;
    ufoBullets.forEach(bullet => {
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.shadowBlur = 0;
  }
  
  function drawParticles() {
    particles.forEach(particle => {
      ctx.fillStyle = `rgba(255, 255, 255, ${particle.life * 0.6})`;
      ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
    });
  }
  
  // Main game loop
  function gameLoop() {
    // Clear canvas
    ctx.fillStyle = 'rgba(8, 16, 26, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Spawn huge asteroid periodically
    const now = Date.now();
    if (now - lastHugeAsteroidTime >= HUGE_ASTEROID_INTERVAL) {
      spawnHugeAsteroid();
      lastHugeAsteroidTime = now;
    }
    
    // Spawn UFO randomly
    if (now - lastUfoTime >= nextUfoInterval) {
      spawnUfo();
      lastUfoTime = now;
      nextUfoInterval = 20000 + Math.random() * 15000; // New random interval for next UFO
    }
    
    // Update
    updateShipAI();
    updateAsteroids();
    updateUfos();
    updateUfoBullets();
    updateBullets();
    updateParticles();
    
    // Draw
    drawStars();
    drawAsteroids();
    drawUfos();
    drawUfoBullets();
    drawShip();
    drawBullets();
    drawParticles();
    
    requestAnimationFrame(gameLoop);
  }
  
  // Start the game
  gameLoop();
})();
</script>
</body>
</html>
